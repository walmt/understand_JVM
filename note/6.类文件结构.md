- 代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。

# 概述

- 近 10 年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。

---

# 无关性的基石

- 各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石。
- 但本节标题中刻意省略了“平台”二字，那是因为笔者注意到虚拟机的另外一种中立特性——语言无关性正越来越被开发者所重视。
- 时至今日，商业机构和开源机构已经在 Java 语言之外发展出一大批在 Java 虚拟机之上运行的语言，如 Clojure、Groovy、JRuby、Jython、Scala等。
- 实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。
- 基于安全方面的考虑，Java 虚拟机规范要求在 Class 文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被 Java 虚拟机所接受的有效的 Class 文件。
- 作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将 Java 虚拟机作为语言的产品交付媒介。
- 使用 Java 编译器可以把 Java 代码编译为存储字节码的 Class 文件，使用 JRuby 等其他语言的编译器一样可以把程序代码编译成 Class 文件，虚拟机并不关心 Class 的来源是何种语言。
- Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。
- 因此，有一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础。

---

# Class类文件的结构

- 任何一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。
- 本章中，笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它并不一定以磁盘文件的形式存在。

* Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个 8 位字节进行存储。
* 根据 Java 虚拟机规范的规定，Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。

- 无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。

* 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。
* 表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。
* ![](https://github.com/walmt/understand_JVM/blob/master/img/26.png?raw=true)

- 无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。

* Class 的结构不像XML等描述语言，由于它没有任何分隔符号，所以在 图26 中的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering,Class 文件中字节序为 Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。接下来我们将一起看看这个表中各个数据项的具体含义。

### 魔数与Class文件的版本

- 每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件。
- 很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如 gif 或者 jpeg 等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。
- 文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。
- Class 文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝？），这个魔数值在 Java 还称做“Oak”语言的时候（大约是 1991 年前后）就已经确定下来了。

* 紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 个字节是次版本号（Minor Version），第 7 和第 8 个字节是主版本号（Major Version）。Java 的版本号是从 45 开始的，JDK1.1 之后的每个 JDK 大版本发布主版本号向上加 1（JDK1.0~1.1 使用了 45.0~45.3 的版本号），高版本的 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的 Class 文件。
> 例如，JDK1.1 能支持版本号为 45.0～45.65535 的 Class 文件，无法执行版本号为 46.0 以上的 Class 文件，而 JDK1.2 则能支持 45.0～46.65535 的 Class 文件。现在，最新的 JDK 版本为 1.7，可生成的 Class 文件主版本号最大值为 51.0。

- 准备了一段最简单的 Java 代码，本章后面的内容都将以这段小程序使用 JDK1.6 编译输出的 Class 文件为基础来进行讲解。

```Java
package org.fenixsoft.clazz;

public class TestClass {
	private int m;

	public int inc() {
		return m + 1;
	}
}
```

### 常量池

- 紧接着主次版本号之后的是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时它还是在 Class 文件中第一个出现的表类型数据项目。
- 由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值（constant_pool_count）。
- 与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的。
> 例：常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。
- 在 Class 文件格式规范制定之时，设计者将第 0 项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为 0 来表示。
- Class 文件结构中只有常量池的容量计数是从 1 开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从 0 开始的。
- 常量池中主要存放两大类常量：字面量（*Literal*）和符号引用（*Symbolic References*）。
- 字面量比较接近于 Java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等。
- 而符号引用则属于编译原理方面的概念，包括了下面三类常量：
>- 类和接口的全限定名（*Fully Qualified Name*）
>- 字段的名称和描述符（*Descriptor*）
>- 方法的名称和描述符
- Java 代码在进行 Javac 编译的时候，并不像 C 和 C++ 那样有“连接”这一步骤，而是在虚拟机加载 Class 文件的时候进行动态连接。
- 在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。
- 当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。
- 常量池中每一项常量都是一个表，在 JDK1.7 之前共有 11 种结构各不相同的表结构数据，在 JDK1.7 中为了更好地支持动态语言调用，又额外增加了 3 种（CONSTANT_MethodHandle_info、CONSTANT_MethodType_info 和 CONSTANT_InvokeDynamic_info）。
- 这 14 种表都有一个共同的特点，就是表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量属于哪种常量类型。
- ![](https://github.com/walmt/understand_JVM/blob/master/img/27.png?raw=true)
> 由于 Class 文件中方法、字段等都需要引用 CONSTANT_Utf8_info 型常量来描述名称，所以 CONSTANT_Utf8_info 型常量的最大长度也就是 Java 中方法、字段名的最大长度。而这里的最大长度就是 length 的最大值，既u2类型能表达的最大值 65535。所以 Java 程序中如果定义了超过 64KB 英文字符的变量或方法名，将会无法编译。
- 在 JDK 的 bin 目录中，Oracle 公司已经为我们准备好一个专门用于分析 Class 文件字节码的工具：javap。
> C:\>javap -verbose TestClass
- 常量项的结构定义：![](https://github.com/walmt/understand_JVM/blob/master/img/28.png?raw=true)![](https://github.com/walmt/understand_JVM/blob/master/img/29.png?raw=true)

### 访问标志

- 在常量池结束之后，紧接着的两个字节代表访问标志（*access_flags*），这个标志用于识别一些类或者接口层次的访问信息，包括：
>- 这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。
>- ![](https://github.com/walmt/understand_JVM/blob/master/img/30.png?raw=true)
- access_flags 中一共有 16 个标志位可以使用，当前只定义了其中 8 个，没有使用到的标志位要求一律为 0。
>- 例子：TestClass 是一个普通 Java 类，不是接口、枚举或者注解，被 public 关键字修饰但没有被声明为 final 和 abstract，并且它使用了 JDK 1.2 之后的编译器进行编译，因此它的 ACC_PUBLIC、ACC_SUPER 标志应当为真，而 ACC_FINAL、ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM 这 6 个标志应当为假，因此它的 access_flags 的值应为：0x0001|0x0020=0x0021。

### 类索引、父类索引与接口索引集合

- 类索引（*this_class*）和父类索引（*super_class*）都是一个 u2 类型的数据，而接口索引集合（*interfaces*）是一组 u2 类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系。
- 类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。
- 由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。
- 接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。
- 类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个 u2 类型的索引值表示，它们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过 CONSTANT_Class_info 类型的常量中的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。
- 对于接口索引集合，入口的第一项——u2 类型的数据为接口计数器（*interfaces_count*），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为 0，后面接口的索引表不再占用任何字节。

### 字段表集合

- 字段表（*field_info*）用于描述接口或者类中声明的变量。字段（*field*）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。可以包括的信息有：
>- 字段的作用域（public、private、protected修饰符）
>- 是实例变量还是类变量（static修饰符）
>- 可变性（final）
>- 并发可见性（volatile修饰符，是否强制从主内存读写）
>- 可否被序列化（transient修饰符）
>- 字段数据类型（基本类型、对象、数组）
>- 字段名称
- 字段表结构：![](https://github.com/walmt/understand_JVM/blob/master/img/31.png?raw=true)

* 字段修饰符放在 access_flags 项目中，它与类中的 access_flags 项目是非常类似的，都是一个 u2 的数据类型，其中可以设置的标志位见。![](https://github.com/walmt/understand_JVM/blob/master/img/32.png?raw=true)
* 在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED 三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE 不能同时选择。接口之中的字段必须有 ACC_PUBLIC、ACC_STATIC、ACC_FINAL 标志，这些都是由 Java 本身的语言规则所决定的。
* 跟随 access_flags 标志的是两项索引值：name_index 和 descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。

- “简单名称”、“描述符”以及前面出现过多次的“全限定名”这三种特殊字符串的概念：
>- 例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”表示全限定名结束。
>- 简单名称是指没有类型和参数修饰的方法或者字段名称，这个类中的`inc()`方法和m字段的简单名称分别是“inc”和“m”。
>- 描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。![](https://github.com/walmt/understand_JVM/blob/master/img/33.png?raw=true)

* 描述符：对于数组类型，每一维度将使用一个前置的“[”字符来描述。
> 如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava/lang/String;”，一个整型数组“int[]”将被记录为“[I”。
- 用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。
>- 如方法`void inc()`的描述符为“()V”，方法`java.lang.String  toString()`的描述符为“()java/lang/String;”
>- 方法`intindexOf(char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex)`的描述符为“([CII[CIII)I”。

- 例子：
>- 对于TestClass.class文件来说，第一个 u2 类型的数据为容量计数器 fields_count，其值为 0x0001，说明这个类只有一个字段表数据。
>- 接下来紧跟着容量计数器的是 access_flags 标志，值为 0x0002，代表 private 修饰符的 ACC_PRIVATE 标志位为真（ACC_PRIVATE 标志的值为 0x0002），其他修饰符为假。代表字段名称的 name_index 的值可从对应的常量表中查得一个 CONSTANT_Utf8_info 类型的字符串，其值为“m”。
>- 代表字段描述符的 descriptor_index 的值也可以从对应的常量表中查得一个 CONSTANT_Utf8_info，指向常量池的字符串“I”。
>- 根据这些信息，我们可以推断出原代码定义的字段为：“private int m;”。

* 字段表都包含的固定数据项目到 descriptor_index 为止就结束了，不过 在descriptor_index 之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。

- 字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。
- 另外，在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。

### 方法表集合

- Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（*access_flags*）、名称索引（*name_index*）、描述符索引（*descriptor_index*）、属性表集合（*attributes*）几项，见。![](https://github.com/walmt/understand_JVM/blob/master/img/34.png?raw=true)
- 这些数据项目的含义也非常类似，仅在访问标志和属性表集合的可选项中有所区别。

* 因为 volatile 关键字和 transient 关键字不能修饰方法，所以方法表的访问标志中没有了 ACC_VOLATILE 标志 和ACC_TRANSIENT 标志。
* 与之相对的，synchronized、native、strictfp 和 abstract 关键字可以修饰方法，所以方法表的访问标志中增加了 ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT 标志。
* 对于方法表，所有标志位及其取值可参见。![](https://github.com/walmt/understand_JVM/blob/master/img/35.png?raw=true)

- 例子：以代码 TestClass 的 Class 文件为例对方法表集合进行分析。
>- 方法表集合的第一个u2类型的数据（即是计数器容量）的值为 0x0002，代表集合中有两个方法（这两个方法为编译器添加的实例构造器<init>和源码中的方法inc()）。
>- 第一个方法的访问标志值为 0x001，也就是只有 ACC_PUBLIC 标志为真，名称索引值对应的常量池的方法名为“<init>”。
>- 描述符索引值对应常量池为“()V”。
>- 属性表计数器 attributes_count 的值为 0x0001 就表示此方法的属性表集合有一项属性。
>- 属性名称索引为对应常量池为“Code”，说明此属性是方法的字节码描述。

- 与字段表集合相对应的，如果父类方法在子类中没有被重写（*Override*），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“<clinit>”方法和实例构造器“<init>” 方法。

* 在 Java 语言中，要重载（*Overload*）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。
* 特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此 Java 语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。
* 但是在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。
* 也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 Class 文件中的。

### 属性表集合

- 属性表（*attribute_info*）在前面的讲解之中已经出现过数次，在 Class 文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。

* 与 Class 文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。
* 为了能正确解析 Class 文件，《Java虚拟机规范（第2版）》 中预定义了 9 项虚拟机实现应当能识别的属性，而在最新的 《Java虚拟机规范（Java SE 7）》 版中，预定义属性已经增加到 21 项，具体内容见。![](https://github.com/walmt/understand_JVM/blob/master/img/36.png?raw=true)![](https://github.com/walmt/understand_JVM/blob/master/img/37.png?raw=true)

- 对于每个属性，它的名称需要从常量池中引用一个 CONSTANT_Utf8_info 类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。
- 一个符合规则的属性表应该满足下图中所定义的结构。![](https://github.com/walmt/understand_JVM/blob/master/img/38.png?raw=true)

##### 1.Code属性

- Java 程序方法体中的代码经过 Javac 编译器处理后，最终变为字节码指令存储在 Code 属性内。Code 属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在 Code 属性，如果方法表有 Code 属性存在，那么它的结构将如图所示。![](https://github.com/walmt/understand_JVM/blob/master/img/39.png?raw=true)
- attribute_name_index 是一项指向 CONSTANT_Utf8_info 型常量的索引，常量值固定为“Code”，它代表了该属性的属性名称，attribute_length 指示了属性值的长度，由于属性名称索引与属性长度一共为 6 字节，所以属性值的长度固定为整个属性表长度减去 6 个字节。
- max_stack 代表了操作数栈（*Operand  Stacks*）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（*Stack Frame*）中的操作栈深度。
- max_locals代表了局部变量表所需的存储空间。
>- 在这里，max_locals 的单位是 Slot,Slot 是虚拟机为局部变量分配内存所使用的最小单位。
>- 对于byte、char、float、int、short、boolean 和 returnAddress 等长度不超过 32 位的数据类型，每个局部变量占用 1 个 Slot，而 double 和 long 这两种 64 位的数据类型则需要两个 Slot 来存放。
>- 方法参数（包括实例方法中的隐藏参数“this”）、显式异常处理器的参数（*Exception Handler Parameter*，就是`try-catch`语句中 catch 块所定义的异常）、方法体中定义的局部变量都需要使用局部变量表来存放。
>- 另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占 Slot 之和作为 max_locals 的值，原因是局部变量表中的 Slot 可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的 Slot 可以被其他局部变量所使用，Javac 编译器会根据变量的作用域来分配 Slot 给各个变量使用，然后计算出 max_locals 的大小。
- code_length和code用来存储Java源程序编译后生成的字节码指令。
>- code_length 代表字节码长度，code 是用于存储字节码指令的一系列字节流。
>- 既然叫字节码指令，那么每个指令就是一个 u1 类型的单字节，当虚拟机读取到 code 中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。
>- 我们知道一个 u1 数据类型的取值范围为 0x00~0xFF，对应十进制的 0~255，也就是一共可以表达 256 条指令，目前，Java 虚拟机规范已经定义了其中约 200 条编码值对应的指令含义。
>- 关于 code_length，有一件值得注意的事情，虽然它是一个 u4 类型的长度值，理论上最大值可以达到 2^32-1。
>- 但是虚拟机规范中明确限制了一个方法不允许超过 65535 条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac 编译器也会拒绝编译。
>- 一般来讲，编写 Java 代码时只要不是刻意去编写一个超长的方法来为难编译器，是不太可能超过这个最大值的限制。
>- 但是，某些特殊情况，例如在编译一个很复杂的 JSP 文件时，某些 JSP 编译器会把 JSP 内容和页面输出的信息归并于一个方法之中，就可能因为方法生成字节码超长的原因而导致编译失败。
- Code 属性是 Class 文件中最重要的一个属性，如果把一个 Java 程序中的信息分为代码（*Code*，方法体里面的 Java 代码）和元数据（*Metadata*，包括类、字段、方法定义及其他信息）两部分，那么在整个 Class 文件中，Code 属性用于描述代码，所有的其他数据项目都用于描述元数据。
>- 以代码 TestClass 的 class 文件为例：
>- 构造器“<init>”方法的Code属性，它的操作数栈的最大深度和本地变量表的容量都为 0x0001，字节码区域所占空间的长度为 0x0005。
>- 虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的 5 个字节，并根据字节码指令表翻译出所对应的字节码指令。
>- 翻译“2A B7 00 0A B1”的过程为：
>- 1）读入2A，查表得0x2A对应的指令为aload_0，这个指令的含义是将第0个Slot中为reference类型的本地变量推送到操作数栈顶。
>- 2）读入B7，查表得0xB7对应的指令为invokespecial，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或它的父类的方法。这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的方法符号引用。
>- 3）读入00  0A，这是invokespecial的参数，查常量池得0x000A对应的常量为实例构造器“＜init＞”方法的符号引用。
>- 4）读入B1，查表得0xB1对应的指令为return，含义是返回此方法，并且返回值为void。
>- 这条指令执行后，当前方法结束。
>- Java虚拟机执行字节码是基于栈的体系结构，但是与一般基于堆栈的零字节指令又不太一样，某些指令（如 invokespecial）后面还会带有参数。

* 在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。
* 这个访问机制对 Java 程序的编写很重要，而它的实现却非常简单，仅仅是通过 Javac 编译器编译的时候把对 this 关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。
* 因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个 Slot 位来存放对象实例的引用，方法参数值从1开始计算。
* 这个处理只对实例方法有效，如果方法声明为 static， 那Args_size 就不会等于 1 而是等于 0 了。

- 在字节码指令之后的是这个方法的显式异常处理表（下文简称异常表）集合，异常表对于 Code 属性来说并不是必须存在的。
- 异常表的格式如图所示，它包含4个字段。![](https://github.com/walmt/understand_JVM/blob/master/img/40.png?raw=true)
- 这些字段的含义为：如果当字节码在第 start_pc 行到第 end_pc 行之间（不含第 end_pc 行）出现了类型为 catch_type 或者其子类的异常（catch_type 为指向一个 CONSTANT_Class_info 型常量的索引），则转到第 handler_pc 行继续处理。当 catch_type 的值为 0 时，代表任意异常情况都需要转向到 handler_pc 处进行处理。
- 异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制。

```
例子：
//Java源码
public int inc（）{
int x；
try{
x=1；
return x；
}catch（Exception e）{
x=2；
return x；
}finally{
x=3；
}
}
//编译后的ByteCode字节码及异常表
public int inc（）；
Code：
Stack=1，Locals=5，Args_size=1
0：iconst_1//try块中的x=1
1：istore_1
2：iload_1//保存x到returnValue中，此时x=1
3：istore 4
5：iconst_3//finaly块中的x=3
6：istore_1
7：iload 4//将returnValue中的值放到栈顶，准备给ireturn返回
9：ireturn
10：astore_2//给catch中定义的Exception e赋值，存储在Slot 2中
11：iconst_2//catch块中的x=2
12：istore_1
13：iload_1//保存x到returnValue中，此时x=2
14：istore 4
16：iconst_3//finaly块中的x=3
17：istore_1
18：iload 4//将returnValue中的值放到栈顶，准备给ireturn返回
20：ireturn
21：astore_3//如果出现了不属于java.lang.Exception及其子类的异常才会走到这里
22：iconst_3//finaly块中的x=3
23：istore_1
24：aload_3//将异常放置到栈顶，并抛出
25：athrow
Exception table：
from to target type
0 5 10 Class java/lang/Exception
0 5 21 any
10 16 21 any
```

- 编译器为这段 Java 源码生成了 3 条异常表记录，对应 3 条可能出现的代码执行路径。
- 从 Java 代码的语义上讲，这 3 条执行路径分别为：
>- 如果 try 语句块中出现属于 Exception 或其子类的异常，则转到 catch 语句块处理。
>- 如果 try 语句块中出现不属于 Exception 或其子类的异常，则转到 finally 语句块处理。
>- 如果 catch 语句块中出现任何异常，则转到 finally 语句块处理。

- 操作过程：
>- 字节码中第 0~4 行所做的操作就是将整数 1 赋值给变量 x，并且将此时 x 的值复制一份副本到最后一个本地变量表的 Slot 中（这个 Slot 里面的值在 ireturn 指令执行前将会被重新读到操作栈顶，作为方法返回值使用。为了讲解方便，给这个 Slot 起了个名字：returnValue）。
>- 如果这时没有出现异常，则会继续走到第 5~9 行，将变量 x 赋值为 3，然后将之前保存在 returnValue 中的整数 1 读入到操作栈顶，最后 ireturn 指令会以 int 形式返回操作栈顶中的值，方法结束。
>- 如果出现了异常，PC 寄存器指针转到第 10 行，第 10~20 行所做的事情是将 2 赋值给变量 x，然后将变量 x 此时的值赋给 returnValue，最后再将变量 x 的值改为 3。
>  方法返回前同样将 returnValue 中保留的整数 2 读到了操作栈顶。
>- 从第 21 行开始的代码，作用是变量 x 的值赋为 3，并将栈顶的异常抛出，方法结束。

##### 2.Exceptions属性

- Exceptions 属性的作用是列举出方法中可能抛出的受查异常（*Checked Excepitons*），也就是方法描述时在 throws 关键字后面列举的异常。
- 结构图![](https://github.com/walmt/understand_JVM/blob/master/img/41.png?raw=true)

##### 3.LineNumberTable属性

- LineNumberTable 属性用于描述 Java 源码行号与字节码行号（字节码的偏移量）之间的对应关系。
- 它并不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 Javac 中分别使用 -g:none 或 -g:lines 选项来取消或要求生成这项信息。
- 如果选择不生成 LineNumberTable 属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。
- LineNumberTable 属性的结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/42.png?raw=true)
- line_number_table 是一个数量为 line_number_table_length、类型 为line_number_info 的集合，line_number_info 表包括了 start_pc 和 line_number 两个 u2 类型的数据项，前者是字节码行号，后者是 Java 源码行号。

##### 4.LocalVariableTable属性

- LocalVariableTable 属性用于描述栈帧中局部变量表中的变量与 Java 源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到 Class 文件之中，可以在 Javac 中分别使用 -g:none 或 -g:vars 选项来取消或要求生成这项信息。
- 如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE 将会使用诸如 arg0、arg1 之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。
- LocalVariableTable 属性的结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/43.png?raw=true)
- 其中，local_variable_info 项目代表了一个栈帧与源码中的局部变量的关联，结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/44.png?raw=true)
>- start_pc 和 length 属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。
>- name_index 和 descriptor_index 都是指向常量池中 CONSTANT_Utf8_info 型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。
>- index 是这个局部变量在栈帧局部变量表中 Slot 的位置。
>- 当这个变量数据类型是 64 位类型时（double 和 long），它占用的 Slot 为 index 和 index+1 两个。

##### 5.SourceFile属性

- SourceFile 属性用于记录生成这个 Class 文件的源码文件名称。
- 这个属性也是可选的，可以分别使用 Javac 的 -g:none 或 -g:source 选项来关闭或要求生成这项信息。
- 在 Java 中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。
- 如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。
- 这个属性是一个定长的属性，其结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/45.png?raw=true)
>- sourcefile_index 数据项是指向常量池中 CONSTANT_Utf8_info 型常量的索引，常量值是源码文件的文件名。

##### 6.ConstantValue属性

- ConstantValue 属性的作用是通知虚拟机自动为静态变量赋值。
- 只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。
- 类似“int x=123”和“static int x=123”这样的变量定义在 Java 程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。
- 对于非 static 类型的变量（也就是实例变量）的赋值是在实例构造器 <init> 方法中进行的。
- 而对于类变量，则有两种方式可以选择:在类构造器 <clinit> 方法中或者使用 ConstantValue 属性。
>- 目前 Sun Javac 编译器的选择是：
>- 如果同时使用 final 和 static 来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者 java.lang.String 的话，就生成 ConstantValue 属性来进行初始化。
>- 如果这个变量没有被 final 修饰，或者并非基本类型及字符串，则将会选择在 <clinit> 方法中进行初始化。

* 虽然有 final 关键字才更符合“ConstantValue”的语义，但虚拟机规范中并没有强制要求字段必须设置了 ACC_FINAL 标志，只要求了有 ConstantValue 属性的字段必须设置 ACC_STATIC 标志而已，对 final 关键字的要求是 Javac 编译器自己加入的限制。
* 而对 ConstantValue 的属性值只能限于基本类型和 String，因为此属性的属性值只是一个常量池的索引号，由于 Class 文件格式的常量类型中只有与基本属性和字符串相对应的字面量，所以就算 ConstantValue 属性想支持别的类型也无能为力。
* ConstantValue属性的结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/46.png?raw=true)
>- 从数据结构中可以看出，ConstantValue 属性是一个定长属性，它的 attribute_length 数据项值必须固定为2。
>- constantvalue_index 数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是 CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info 常量中的一种。

##### 7.InnerClasses属性

- InnerClasses 属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成 InnerClasses 属性。
- 该属性的结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/47.png?raw=true)
- 数据项 number_of_classes 代表需要记录多少个内部类信息，每一个内部类的信息都由一个 inner_classes_info 表进行描述。inner_classes_info 表的结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/48.png?raw=true)
>- inner_class_info_index 和 outer_class_info_index 都是指向常量池中 CONSTANT_Class_info 型常量的索引，分别代表了内部类和宿主类的符号引用。
>- inner_name_index 是指向常量池中 CONSTANT_Utf8_info 型常量的索引，代表这个内部类的名称，如果是匿名内部类，那么这项值为 0。
>- inner_class_access_flags 是内部类的访问标志，类似于类的 access_flags，它的取值范围见图。![](https://github.com/walmt/understand_JVM/blob/master/img/49.png?raw=true)

##### 8.Deprecated及Synthetic属性

- Deprecated 和 Synthetic 两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。
- Deprecated 属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用 @deprecated 注释进行设置。
- Synthetic 属性代表此字段或者方法并不是由 Java 源码直接产生的，而是由编译器自行添加的，在 JDK 1.5 之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的 ACC_SYNTHETIC 标志位，其中最典型的例子就是 Bridge Method。
- 所有由非用户代码产生的类、方法及字段都应当至少设置 Synthetic 属性和 ACC_SYNTHETIC 标志位中的一项，唯一的例外是实例构造器“<init>”方法和类构造器“<clinit>”方法。
- Deprecated和Synthetic属性的结构非常简单，见图。![](https://github.com/walmt/understand_JVM/blob/master/img/50.png?raw=true)
>- 其中 attribute_length 数据项的值必须为 0x00000000，因为没有任何属性值需要设置。

##### 9.StackMapTable属性

- StackMapTable 属性在 JDK 1.6 发布后增加到了 Class 文件规范中，它是一个复杂的变长属性，位于 Code 属性的属性表中。
- 这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（*Type Checker*）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。
- 新的验证器在同样能保证 Class 文件合法性的前提下，省略了在运行期通过数据流分析去确认字节码的行为逻辑合法性的步骤，而是在编译阶段将一系列的验证类型（*Verification Types*）直接记录在 Class 文件之中，通过检查这些验证类型代替了类型推导过程，从而大幅提升了字节码验证的性能。
- StackMapTable 属性中包含零至多个栈映射帧（*Stack Map Frames*），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示该执行到该字节码时局部变量表和操作数栈的验证类型。
- 类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。
- StackMapTable 属性的结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/51.png?raw=true)
>- 《Java虚拟机规范（Java SE 7版）》明确规定：在版本号大于或等于 50.0 的 Class 文件中，如果方法的 Code 属性中没有附带 StackMapTable 属性，那就意味着它带有一个隐式的 StackMap 属性。
>- 这个 StackMap 属性的作用等同于 number_of_entries 值为 0 的 StackMapTable 属性。
>- 一个方法的 Code 属性最多只能有一个 StackMapTable 属性，否则将抛出 ClassFormatError 异常。

##### 10.Signature属性

- Signature 属性在 JDK 1.5 发布后增加到了 Class 文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中。
- 在 JDK 1.5 中大幅增强了 Java 语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（*Type Variables*）或参数化类型（*Parameterized Types*），则 Signature 属性会为它记录泛型签名信息。
- 之所以要专门使用这样一个属性去记录泛型类型，是因为 Java 语言的泛型采用的是擦除法实现的伪泛型，在字节码（*Code*属性）中，泛型信息编译（类型变量、参数化类型）之后都通通被擦除掉。
- 使用擦除法的好处是实现简单（主要修改 Javac 编译器，虚拟机内部只做了很少的改动）、非常容易实现 Backport，运行期也能够节省一些类型所占的内存空间。
- 但坏处是运行期就无法像 C# 等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得到泛型信息。
- Signature 属性就是为了弥补这个缺陷而增设的，现在 Java 的反射 API 能够获取泛型类型，最终的数据来源也就是这个属性。
- ignature属性的结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/52.png?raw=true)
>- 其中 signature_index 项的值必须是一个对常量池的有效索引。
>- 常量池在该索引处的项必须是 CONSTANT_Utf8_info 结构，表示类签名、方法类型签名或字段类型签名。
>- 如果当前的 Signature 属性是类文件的属性，则这个结构表示类签名，如果当前的 Signature 属性是方法表的属性，则这个结构表示方法类型签名，如果当前 Signature 属性是字段表的属性，则这个结构表示字段类型签名。

##### 11.BootstrapMethods属性

- BootstrapMethods 属性在 JDK1.7 发布后增加到了 Class 文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存 invokedynamic 指令引用的引导方法限定符。
- 《Java虚拟机规范（Java SE 7版）》规定，如果某个类文件结构的常量池中曾经出现过 CONSTANT_InvokeDynamic_info 类型的常量，那么这个类文件的属性表中必须存在一个明确的 BootstrapMethods 属性。
- 另外，即使 CONSTANT_InvokeDynamic_info 类型的常量在常量池中出现过多次，类文件的属性表中最多也只能有一个BootstrapMethods属性。
- BootstrapMethods 属性与 JSR-292 中的 InvokeDynamic 指令和 java.lang.Invoke 包关系非常密切，要介绍这个属性的作用，必须先弄清楚 InovkeDynamic 指令的运作原理。
- BootstrapMethods属性的结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/53.png?raw=true)
- 其中引用到的bootstrap_method结构见图。![](https://github.com/walmt/understand_JVM/blob/master/img/54.png?raw=true)

* BootstrapMethods 属性中，num_bootstrap_methods 项的值给出了 bootstrap_methods[] 数组中的引导方法限定符的数量。
* 而 bootstrap_methods[] 数组的每个成员包含了一个指向常量池 CONSTANT_MethodHandle 结构的索引值。
* 它代表了一个引导方法，还包含了这个引导方法静态参数的序列（可能为空）。
* bootstrap_methods[] 数组中的每个成员必须包含以下3项内容：
>- ootstrap_method_ref：bootstrap_method_ref 项的值必须是一个对常量池的有效索引。常量池在该索引处的值必须是一个 CONSTANT_MethodHandle_info 结构。
>- num_bootstrap_arguments：num_bootstrap_arguments 项的值给出了 bootstrap_arguments[] 数组成员的数量。
>- bootstrap_arguments[]：bootstrap_arguments[] 数组的每个成员必须是一个对常量池的有效索引。
>- 常量池在该索引处必须是下列结构之一：CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info 或 CONSTANT_MethodType_info。

---

# 字节码指令简介

- Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，*Opcode*）以及跟随其后的零至多个代表此操作所需参数（称为操作数，*Operands*）而构成。
- 由于 Java 虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。

* 字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了 Java 虚拟机操作码的长度为一个字节（即 0~255），这意味着指令集的操作码总数不可能超过 256 条。
* 又由于 Class 文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构。
* 如果要将一个 16 位长度的无符号整数使用两个无符号字节存储起来（将它们命名为 byte1 和 byte2），那它们的值应该是这样的：
```
（byte1＜＜8）|byte2
```

- 这种操作在某种程度上会导致解释执行字节码时损失一些性能。
- 但这样做的优势也非常明显，放弃了操作数长度对齐，就意味着可以省略很多填充和间隔符号。
- 用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。
- 这种追求尽可能小数据量、高传输效率的设计是由 Java 语言设计之初面向网络、智能家电的技术背景所决定的，并一直沿用至今。

* 如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效地工作：
```
do {
    自动计算 PC 寄存器的值加 1;
    根据 PC 寄存器的指示位置，从字节码流中取出操作码;
    if(字节码存在操作数) 从字节码流中取出操作数;
    执行操作码所定义的操作;
} while (字节码流长度 > 0);
```

### 字节码与数据类型

- 在 Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。
- 例如：
>- iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。
>- 这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在 Class 文件中它们必须拥有各自独立的操作码。

* 对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务。
* i 代表对 int 类型的数据操作，l 代表 long,s 代表 short,b 代表 byte,c 代表 char,f 代表 float,d 代表 double,a 代表 reference。
* 也有一些指令的助记符中没有明确地指明操作类型的字母。如 arraylength 指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。
* 还有另外一些指令，如无条件跳转指令 goto 则是与数据类型无关的。

- 由于 Java 虚拟机的操作码长度只有一个字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力：
>- 如果每一种与数据类型相关的指令都支持 Java 虚拟机所有运行时数据类型的话，那指令的数量恐怕就会超出一个字节所能表示的数量范围了。
>- 因此，Java 虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它。
>- 换句话说，指令集将会故意被设计成非完全独立的（Java 虚拟机规范中把这种特性称为“Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令）。
>- 有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。

* ![](https://github.com/walmt/understand_JVM/blob/master/img/55.png?raw=true)
* ![](https://github.com/walmt/understand_JVM/blob/master/img/56.png?raw=true)
* 图55、56 列举了 Java 虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换 opcode 列的指令模板中的 T，就可以得到一个具体的字节码指令。
- 如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。
>- 例如，load 指令有操作 int 类型的 iload，但是没有操作 byte 类型的同类指令。

- 注意，大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。
- 编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展（*Sign-Extend*）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（*Zero-Extend*）为相应的 int 类型数据。
- 与之类似，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。
- 因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型（*ComputationalType*）。

* 阅读字节码作为了解 Java 虚拟机的基础技能，是一项应当熟练掌握的能力。
* 笔者将字节码操作按用途大致分为 9 类，按照分类来为读者概略介绍一下这些指令的用法。
* 如果读者需要了解更详细的信息，可以参考阅读笔者翻译的 《Java虚拟机规范（Java SE 7版）》 的第 6 章。

### 加载和存储指令

- 加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括如下内容：
>- 将一个局部变量加载到操作栈：iload、iload_＜n＞、lload、lload_＜n＞、fload、fload_＜n＞、dload、dload_＜n＞、aload、aload_＜n＞。
>- 将一个数值从操作数栈存储到局部变量表：istore、istore_＜n＞、lstore、lstore_＜n＞、fstore、fstore_＜n＞、dstore、dstore_＜n＞、astore、astore_＜n＞。
>- 一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_＜i＞、lconst_＜l＞、fconst_＜f＞、dconst_＜d＞。
>- 扩充局部变量表的访问索引的指令：wide。
>- 存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作。
>- 除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。

* 上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如 iload_＜n＞），这些指令助记符实际上是代表了一组指令（例如 iload_＜n＞，它代表了 iload_0、iload_1、iload_2和iload_3 这几条指令）。
* 这几组指令都是某个带有一个操作数的通用指令（例如 iload）的特殊形式，对于这若干组特殊指令来说，它们省略掉了显式的操作数，不需要进行取操作数的动作，实际上操作数就隐含在指令中。
* 除了这点之外，它们的语义与原生的通用指令完全一致（例如 iload_0 的语义与操作数为 0 时的 iload 指令语义完全一致）。
* 这种指令表示方法在本书以及《Java虚拟机规范》中都是通用的。

### 运算指令

- 运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。
- 大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。
- 无论是哪种算术指令，都使用 Java 虚拟机的数据类型，由于没有直接支持 byte、short、char和boolean 类型的算术指令，对于这类数据的运算，应使用操作 int 类型的指令代替。
- 整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现。
- 所有的算术指令如下：
>- 加法指令：iadd、ladd、fadd、dadd。
>- 减法指令：isub、lsub、fsub、dsub。
>- 乘法指令：imul、lmul、fmul、dmul。
>- 除法指令：idiv、ldiv、fdiv、ddiv。
>- 求余指令：irem、lrem、frem、drem。
>- 取反指令：ineg、lneg、fneg、dneg。
>- 位移指令：ishl、ishr、iushr、lshl、lshr、lushr。
>- 按位或指令：ior、lor。
>- 按位与指令：iand、land。
>- 按位异或指令：ixor、lxor。
>- 局部变量自增指令：iinc。
>- 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp。

##### 运算异常

* Java 虚拟机的指令集直接支持了在《Java语言规范》中描述的各种对整数及浮点数操作的语义。
* 数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能会是一个负数，这种数学上不可能出现的溢出现象，对于程序员来说是很容易理解的。
* 但其实 Java 虚拟机规范没有明确定义过整型数据溢出的具体运算结果。
* 仅规定了在处理整型数据时，只有除法指令（idiv 和 ldiv）以及求余指令（irem 和 lrem）中当出现除数为零时会导致虚拟机抛出 ArithmeticException 异常，其余任何整型数运算场景都不应该抛出运行时异常。

##### 处理浮点数

- Java 虚拟机规范要求虚拟机实现在处理浮点数时，必须严格遵循 IEEE 754 规范中所规定的行为和限制。
- 也就是说，Java 虚拟机必须完全支持 IEEE  754 中定义的非正规浮点数值（*Denormalized Floating-Point Numbers*）和逐级下溢（*Gradual Underflow*）的运算规则。
- 这些特征将会使某些数值算法处理起来变得相对容易一些。

##### 浮点数运算

* Java 虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值。
* 如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。
* 这种舍入模式也是 IEEE 754 规范中的默认舍入模式，称为向最接近数舍入模式。

##### 浮点数转化为整数

- 在把浮点数转换为整数时，Java 虚拟机使用 IEEE 754 标准中的向零舍入模式。
- 这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。
- 向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。

##### 处理浮点数运算

- Java 虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是 Java 语言中的异常，请读者勿与 IEEE 754 规范中的浮点异常互相混淆，IEEE 754 的浮点异常是一种运算信号）。
- 当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值来表示。
- 所有使用NaN值作为操作数的算术操作，结果都会返回NaN。

##### 数值比较

- 在对 long 类型数值进行比较时，虚拟机采用带符号的比较方式。
- 而对浮点数值进行比较时（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用 IEEE 754 规范所定义的无信号比较（*Nonsignaling Comparisons*）方式。

### 类型转换指令

- 类型转换指令可以将两种不同的数值类型进行相互转换。
- 这些转换操作一般用于实现用户代码中的显式类型转换操作。
- 或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。

##### 小范围类型向大范围类型的安全转换

- Java 虚拟机直接支持（即转换时无需显式的转换指令）以下数值类型的宽化类型转换（*Widening Numeric Conversions*，即小范围类型向大范围类型的安全转换）：

>- int类型到long、float或者double类型。
>- long类型到float、double类型。
>- float类型到double类型。

##### 窄化类型转换（*Narrowing Numeric Conversions*）

- 必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。
- 窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。

##### int/long 窄化为 整数类型 T 

* 在将 int 或 long 类型窄化转换为整数类型 T 的时候，转换过程仅仅是简单地丢弃除最低位N个字节以外的内容。
* N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。
* 这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低N个字节的首位了。

##### 浮点值窄化规则

###### 窄化为 int/long

- 在将一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）的时候，将遵循以下转换规则：
>- 如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0。
>- 如果浮点值不是无穷大的话，浮点值使用 IEEE 754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T（int 或 long）的表示范围之内，那转换结果就是 v。
>- 否则，将根据v的符号，转换为T所能表示的最大或者最小正数。

###### 窄化为 float

- 从 double 类型到 float 类型的窄化转换过程与 IEEE 754 中定义的一致，通过 IEEE 754 向最接近数舍入模式舍入得到一个可以使用float类型表示的数字。
- 如果转换结果的绝对值太小而无法使用 float 来表示的话，将返回 float 类型的正负零。
- 如果转换结果的绝对值太大而无法使用 float 来表示的话，将返回 float 类型的正负无穷大，对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值。

##### 注意

- 尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是 Java 虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。

### 对象创建与访问指令

- 虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（数组和普通类的类型创建过程是不同的）。
- 对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下：
>- 创建类实例的指令：new。
>- 创建数组的指令：newarray、anewarray、multianewarray。
>- 访问类字段（static 字段，或者称为类变量）和实例字段（非 static 字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic。
>- 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。
>- 将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。
>- 取数组长度的指令：arraylength。
>- 检查类实例类型的指令：instanceof、checkcast。

### 操作数栈管理指令

- 如同操作一个普通数据结构中的堆栈那样，Java 虚拟机提供了一些用于直接操作操作数栈的指令，包括：

>- 将操作数栈的栈顶一个或两个元素出栈：pop、pop2。
>- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。
>- 将栈最顶端的两个数值互换：swap。

### 控制转移指令

- 控制转移指令可以让 Java 虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序。
- 从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改 PC 寄存器的值。控制转移指令如下：
>- 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。
>- 复合条件分支：tableswitch、lookupswitch。
>- 无条件分支：goto、goto_w、jsr、jsr_w、ret。

- 在 Java 虚拟机中有专门的指令集用来处理 int 和 reference 类型的条件分支比较操作，为了可以无须明显标识一个实体值是否 null，也有专门的指令用来检测 null 值。

##### 比较规则

- 与前面算术运算时的规则一致，对于 boolean 类型、byte 类型、char 类型和 short 类型的条件分支比较操作，都是使用 int 类型的比较指令来完成。
- 而对于 long 类型、float 类型和 double 类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp）。
- 运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。
- 由于各种类型的比较最终都会转化为 int 类型的比较操作，int 类型比较是否方便完善就显得尤为重要，所以 Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的。

### 方法调用和返回指令

- 方法调用（分派、执行过程）将在后面具体讲解，这里仅列举以下 5 条用于方法调用的指令：
>- invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是 Java 语言中最常见的方法分派方式。
>- invokeinterface 指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
>- invokespecial 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
>- invokestatic 指令用于调用类方法（static 方法）。
>- invokedynamic 指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在 Java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。

- 方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的。
- 包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、dreturn和areturn。
- 另外还有一条 return 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用。

### 异常处理指令

- 在 Java 程序中显式抛出异常的操作（throw 语句）都由 athrow 指令来实现。
- 除了用 throw 语句显式抛出异常情况之外，Java 虚拟机规范还规定了许多运行时异常会在其他 Java 虚拟机指令检测到异常状况时自动抛出。
- 例如，在前面介绍的整数运算中，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出 ArithmeticException 异常。
- 而在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（很久之前曾经使用 jsr 和 ret 指令来实现，现在已经不用了），而是采用异常表来完成的。

### 同步指令

- Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（*Monitor*）来支持的。

##### 方法级同步

- 方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。
- 虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法。
- 当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置。
- 如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。
- 在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。
- 如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。

##### 代码同步演示

- 同步一段指令集序列通常是由 Java 语言中的 synchronized 语句块来表示的。
- Java 虚拟机的指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义。
- 正确实现 synchronized 关键字需要 Javac 编译器与 Java 虚拟机两者共同协作支持。

```Java
void onlyMe（Foo f）{
synchronized（f）{
doSomething（）；
}
}
```

- 编译后生成的字节码序列

```Javac
Method void onlyMe（Foo）
0 aload_1//将对象f入栈
1 dup//复制栈顶元素（即f的引用）
2 astore_2//将栈顶元素存储到局部变量表Slot 2中
3 monitorenter//以栈顶元素（即f）作为锁，开始同步
4 aload_0//将局部变量Slot 0（即this指针）的元素入栈
5 invokevirtual#5//调用doSomething（）方法
8 aload_2//将局部变量Slow 2的元素（即f）入栈
9 monitorexit//退出同步
10 goto 18//方法正常结束，跳转到18返回
13 astore_3//从这步开始是异常路径，见下面异常表的Taget 13
14 aload_2//将局部变量Slow 2的元素（即f）入栈
15 monitorexit//退出同步
16 aload_3//将局部变量Slow 3的元素（即异常对象）入栈
17 athrow//把异常对象重新抛出给onlyMe（）方法的调用者
18 return//方法正常返回
Exception table：
FromTo Target Type
4 10 13 any
13 16 13 any
```

- 编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须执行其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。
- 从代码的字节码序列中可以看到，为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行。
- 编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。

---

# 公有设计和私有实现

- Java 虚拟机规范描绘了 Java 虚拟机应有的共同程序存储格式：Class 文件格式以及字节码指令集。
- 这些内容与硬件、操作系统及具体的 Java 虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看做是程序在各种 Java 平台实现之间互相安全地交互的手段。

### 公有设计与私有实现之间的分界线

- 理解公有设计与私有实现之间的分界线是非常有必要的。
- Java 虚拟机实现必须能够读取 Class 文件并精确实现包含在其中的 Java 虚拟机代码的语义。
- 拿着 Java 虚拟机规范一成不变地逐字实现其中要求的内容当然是一种可行的途径，但一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是完全可行的，并且虚拟机规范中明确鼓励实现者这样做。
- 只要优化后 Class 文件依然可以被正确读取，并且包含在其中的语义能得到完整的保持，那实现者就可以选择任何方式去实现这些语义。
- 虚拟机后台如何处理 Class 文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可。

### 虚拟机主要的实现方式

- 虚拟机实现者可以使用这种伸缩性来让 Java 虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于 Java 虚拟机实现的目标和关注点是什么。
- 虚拟机实现的方式主要有以下两种：
>- 将输入的 Java 虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。
>- 将输入的 Java 虚拟机代码在加载或执行时翻译成宿主机 CPU 的本地指令集（即 JIT 代码生成技术）。
- 精确定义的虚拟机和目标文件格式不应当对虚拟机实现者的创造性产生太多的限制。
- Java 虚拟机应被设计成可以允许有众多不同的实现，并且各种实现可以在保持兼容性的同时提供不同的、新的、有趣的解决方案。

---

# Class 文件结构的发展

### Class 文件结构历史

- Class 文件结构自 Java 虚拟机规范第 1 版订立以来，已经有十多年的历史。
- 这十多年间，Java 技术体系有了翻天覆地的改变，JDK 的版本号已经从 1.0 提升到了 1.7。
- 相对于语言、API 以及 Java 技术体系中其他方面的变化，Class 文件结构一直处于比较稳定的状态。
- Class 文件的主体结构、字节码指令的语义和数量几乎没有出现过变动。
- 所有对 Class 文件格式的改进，都集中在向访问标志、属性表这些在设计上就可扩展的数据结构中添加内容。

### Class 文件格式变化

- 如果以《Java虚拟机规范（第2版）》为基准进行比较的话，那么在后续 Class 文件格式的发展过程中，访问标志里新加入了 ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_BRIDGE、ACC_VARARGS 共 5 个标志。
- 而属性表集合中，在 JDK 1.5 到 JDK 1.7 版本之间一共增加了 12 项新的属性，这些属性大部分用于支持 Java 中许多新出现的语言特性，如枚举、变长参数、泛型、动态注解等。
- 还有一些是为了支持性能改进和调试信息，譬如 JDK 1.6 的新类型校验器的StackMapTable 属性和对非 Java 代码调试中用到的 SourceDebugExtension 属性。

###### Class 文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是 Java 技术体系实现平台无关、语言无关两项特性的重要支柱。
